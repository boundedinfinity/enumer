package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/boundedinfinity/asciibox"
	"github.com/boundedinfinity/go-commoner/stringer"
)

const (
	FilePermissions = 0755
)

var (
	Header = []string{
		"===== DO NOT EDIT =====",
		"Manual changes will be overwritten.",
		"Generated by github.com/boundedinfinity/enumer",
	}
)

type argsData struct {
	Path       string
	Header     string
	HeaderFrom string
	SkipFormat bool
	Debug      bool
}

type templateData struct {
	TypeName   string
	StructName string
	Package    string
	Dir        string
	Filename   string
	Path       string
	Items      []string
	BaseType   string
	Header     string
	SkipFormat bool
}

func main() {
	var args argsData

	data := templateData{
		Items: []string{},
	}

	flag.StringVar(&args.Path, "path", "", "The input file used for the enum being generated.")
	flag.StringVar(&args.Header, "header", "", "The header contents.")
	flag.StringVar(&args.HeaderFrom, "header-from", "", "Path to file containing the header contents.")
	flag.BoolVar(&args.SkipFormat, "skip-format", false, "Skip source formatting.")
	flag.BoolVar(&args.Debug, "debug", false, "Enabled debugging.")
	flag.Parse()

	if err := processArgs(args, &data); err != nil {
		handleErr(err)
	}

	if err := getInfo(args, &data); err != nil {
		handleErr(err)
	}

	if err := processHeader(args, &data); err != nil {
		handleErr(err)
	}

	bs, err := processTemplate(data)

	if err != nil {
		handleErr(err)
	}

	if err := processWrite(data, bs); err != nil {
		handleErr(err)
	}
}

func processArgs(args argsData, data *templateData) error {
	if args.Path == "" {
		return errors.New("input cannot be empty")
	}

	if !stringer.EndsWith(args.Path, ".enum.go") {
		return errors.New("must be a .enum.go file")
	}

	data.Path = args.Path
	data.Path = strings.ReplaceAll(data.Path, ".enum.go", ".enum.gen.go")

	data.Dir = filepath.Dir(args.Path)
	data.Filename = filepath.Base(args.Path)
	data.SkipFormat = args.SkipFormat

	return nil
}

func getInfo(args argsData, data *templateData) error {
	src, err := os.ReadFile(args.Path)

	if err != nil {
		return err
	}

	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, data.Path, src, parser.ParseComments)

	if err != nil {
		return err
	}

	type context struct {
		typeName     string
		structName   string
		structFields []string
	}

	m := map[string]*context{}

	ast.Inspect(parsed, func(x ast.Node) bool {
		switch t := x.(type) {
		case *ast.File:
			data.Package = t.Name.Name
		case *ast.TypeSpec:
			name := t.Name.Name

			switch t.Type.(type) {
			case *ast.StructType:
				for _, field := range t.Type.(*ast.StructType).Fields.List {
					fieldType := types.ExprString(field.Type)

					if c, ok := m[fieldType]; ok {
						if c.structName == "" {
							c.structName = name
						}

						c.structFields = append(c.structFields, field.Names[0].Name)
					}
				}
			case ast.Expr:
				if _, ok := m[name]; !ok {
					m[name] = &context{typeName: name}
				}
			}
		default:
			if args.Debug {
				fmt.Printf("skipping %v\n", t)
			}
		}

		return true
	})

	for _, ctx := range m {
		if ctx != nil && ctx.structName != "" && len(ctx.structFields) > 0 {
			data.TypeName = ctx.typeName
			data.StructName = ctx.structName
			data.Items = append(data.Items, ctx.structFields...)
		}
	}

	return nil
}

func handleErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func processWrite(data templateData, bs []byte) error {
	err := os.MkdirAll(data.Dir, FilePermissions)

	if err != nil {
		return err
	}

	if err := os.WriteFile(data.Path, bs, FilePermissions); err != nil {
		return err
	}

	return nil
}

func processHeader(args argsData, data *templateData) error {
	var headerContent []string

	if args.Header != "" {
		headerContent = []string{args.Header}
	} else if args.HeaderFrom != "" {
		file, err := os.Open(args.HeaderFrom)

		if err != nil {

			return err
		}

		defer file.Close()

		scanner := bufio.NewScanner(file)
		headerContent = append(headerContent, scanner.Text())

		if err := scanner.Err(); err != nil {
			return err
		}
	} else {
		headerContent = Header
	}

	data.Header = asciibox.Box(
		headerContent,
		asciibox.BoxOptions{
			Alignment: asciibox.Alignment_Left,
		},
	)

	return nil
}

func processTemplate(data templateData) ([]byte, error) {
	funcs := template.FuncMap{
		"title": func(s string) string {
			return strings.Title(s)
		},
		"lower": func(s string) string {
			return strings.ToLower(s)
		},
	}

	t, err := template.New(data.Filename).Funcs(funcs).Parse(standaloneTmpl)

	if err != nil {
		return []byte{}, nil
	}

	var b bytes.Buffer

	if err := t.Execute(&b, data); err != nil {
		return []byte{}, err
	}

	if data.SkipFormat {
		return b.Bytes(), nil
	} else {
		return format.Source(b.Bytes())
	}
}

var standaloneTmpl = `
{{ .Header }}

package {{ .Package }}

import (
	"database/sql/driver"
	"fmt"
	
	"github.com/boundedinfinity/enumer"
	"github.com/boundedinfinity/go-commoner/slicer"
)

{{- $typeName := .TypeName }}
{{- $structName := .StructName }}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} Stringer implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) String() string {
	return string(t)
}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} JSON marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) MarshalJSON() ([]byte, error) {
	return enumer.MarshalJSON(t)
}

func (t *{{ $typeName }}) UnmarshalJSON(data []byte) error {
	return enumer.UnmarshalJSON(data, t, {{ title $structName }}.Parse)
}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} YAML marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) MarshalYAML() (interface{}, error) {
	return enumer.MarshalYAML(t)
}

func (t *{{ $typeName }}) UnmarshalYAML(unmarshal func(interface{}) error) error {
	return enumer.UnmarshalYAML(unmarshal, t, {{ title $structName }}.Parse)
}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} SQL Database marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) Value() (driver.Value, error) {
	return enumer.Value(t)
}

func (t *{{ $typeName }}) Scan(value interface{}) error {
	return enumer.Scan(value, t, {{ title $structName }}.Parse)
}

// /////////////////////////////////////////////////////////////////
//
//  Enumeration
//
// /////////////////////////////////////////////////////////////////

var {{ title $structName }} = struct {
	{{ $structName }}
	Err error
	Values []{{ $typeName }}
}{
	{{ $structName }}: {{ $structName }}{
	{{- range $field := .Items }}
		{{ $field }}: {{ $typeName -}}("{{- $field -}}"),
	{{- end }}
	},
	Err: fmt.Errorf("invalid {{ $typeName }}"),
}

func init() {
	{{ title $structName }}.Values = []{{ $typeName -}} {
	{{- range $field := .Items }}
		{{ title $structName }}.{{ $field }},
	{{- end }}
	}
}

func (t {{ $structName }}) newErr(a any, values ...{{ $typeName }}) error {
	return fmt.Errorf(
		"invalid %w value '%v'. Must be one of %v",
		{{ title $structName }}.Err, 
		a, 
		slicer.Join(values, ", "),
	)
}

func (t {{ $structName }}) ParseFrom(v string, values ...{{ $typeName }}) ({{ $typeName }}, error) {
	f, ok := slicer.FindFn(values, enumer.IsEq[string, {{ $typeName }}](v))

	if !ok {
		return f, t.newErr(v, values...)
	}

	return f, nil
}

func (t {{ $structName }}) Parse(v string) ({{ $typeName }}, error) {
	return t.ParseFrom(v, {{ title $structName }}.Values...)
}

func (t {{ $structName }}) IsFrom(v string, values ...{{ $typeName }}) bool {
	return slicer.ContainsFn(values, enumer.IsEq[string, {{ $typeName }}](v))
}

func (t {{ $structName }}) Is(v string) bool {
	return t.IsFrom(v, {{ title $structName }}.Values...)
}
`
