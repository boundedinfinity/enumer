package main

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/boundedinfinity/asciibox"
	"github.com/boundedinfinity/go-commoner/idiomatic/caser"
	"github.com/boundedinfinity/go-commoner/idiomatic/extentioner"
	"github.com/boundedinfinity/go-commoner/idiomatic/pather"
	"github.com/boundedinfinity/go-commoner/idiomatic/stringer"
	"github.com/gertd/go-pluralize"
	"gopkg.in/yaml.v2"
)

//go:embed settings.json
var vscodeSettingsContext string

const (
	FilePermissions = 0755
)

var (
	jsonSchemaName     = "enum.schema.json"
	vscodeSettingsName = "settings.json"

	Header = []string{
		"===== DO NOT EDIT =====",
		"Manual changes will be overwritten.",
		"Generated by github.com/boundedinfinity/enumer",
	}
)

type enumData struct {
	Type        string        `json:"type" yaml:"type"`
	Struct      string        `json:"struct" yaml:"struct"`
	Package     string        `json:"package" yaml:"package"`
	InputPath   string        `json:"input-path" yaml:"input-path"`
	OutputPath  string        `json:"output-path" yaml:"output-path"`
	Desc        string        `json:"desc" yaml:"desc"`
	Header      string        `json:"header" yaml:"header"`
	HeaderFrom  string        `json:"header-from" yaml:"header-from"`
	HeaderLines []string      `json:"header-lines" yaml:"header-lines"`
	SkipFormat  bool          `json:"skip-format" yaml:"skip-format"`
	Debug       bool          `json:"debug" yaml:"debug"`
	Overwrite   bool          `json:"overwrite" yaml:"overwrite"`
	Serialize   enumSerialize `json:"serialize" yaml:"serialize"`
	Values      []enumvalue   `json:"values" yaml:"values"`
}

type enumSerialize struct {
	Type  string `json:"type" yaml:"type"`
	Value string `json:"value" yaml:"value"`
}

type enumvalue struct {
	Name       string `json:"name" yaml:"name"`
	Serialized string `json:"serialized" yaml:"serialized"`
}

type argsData struct {
	InputPath  string
	SkipFormat bool
	Debug      bool
	VsCode     string
	Serialize  string
	Overwrite  bool
}

func handleErr(err error) {
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
}

func main() {
	var args argsData

	if err := processArgs(&args); err != nil {
		handleErr(err)
	}

	if args.VsCode != "" {
		if err := processJsonSchema(args); err != nil {
			handleErr(err)
		}
	} else {
		var enum enumData

		if err := processEnum(args, &enum); err != nil {
			handleErr(err)
		}

		bs, err := processTemplate(enum)

		if err != nil {
			handleErr(err)
		}

		if err := processWrite(enum, bs); err != nil {
			handleErr(err)
		}
	}
}

func generateJsonSchema() string {
	m := map[string]any{
		"$schema": "http://json-schema.org/draft-07/schema",
		"title":   "Bounded Infinity enumeration tool",
		"type":    "object",
		"version": "1.0.19",
		"properties": map[string]any{
			"type": map[string]any{
				"type": "string",
			},
			"package": map[string]any{
				"type": "string",
			},
			"output-path": map[string]any{
				"type": "string",
			},
			"desc": map[string]any{
				"type": "string",
			},
			"header": map[string]any{
				"type": "string",
			},
			"header-from": map[string]any{
				"type": "string",
			},
			"serialize": map[string]any{
				"type": "object",
				"properties": map[string]any{
					"type": map[string]any{
						"type": "string",
						"enum": caser.ConverterCombinations(),
					},
					"value": map[string]any{
						"type": "string",
						"enum": caser.ConverterCombinations(),
					},
				},
			},
			"skip-format": map[string]any{
				"type": "boolean",
			},
			"debug": map[string]any{
				"type": "boolean",
			},
			"values": map[string]any{
				"type": "array",
				"items": map[string]any{
					"type": "object",
					"properties": map[string]any{
						"name": map[string]any{
							"type": "string",
						},
						"serialized": map[string]any{
							"type": "string",
						},
					},
				},
			},
		},
	}

	bs, err := json.MarshalIndent(m, "", "    ")

	if err != nil {
		panic(err)
	}

	return string(bs)
}

func processJsonSchema(args argsData) error {
	projectSettingsDir := pather.Join(args.VsCode, ".vscode")

	if _, err := pather.Dirs.EnsureErr(projectSettingsDir); err != nil {
		return err
	}

	projectSettingsPath := pather.Join(projectSettingsDir, vscodeSettingsName)

	if pather.Paths.Exists(projectSettingsPath) {
		name := fmt.Sprintf("enumer-schema-%v", vscodeSettingsName)
		projectSettingsPath = pather.Join(projectSettingsDir, name)

		if err := os.WriteFile(projectSettingsPath, []byte(vscodeSettingsContext), FilePermissions); err != nil {
			return err
		}

		fmt.Printf("Add the contents of the %v file to your %v file.",
			name,
			vscodeSettingsName,
		)
	} else {
		if err := os.WriteFile(projectSettingsPath, []byte(vscodeSettingsContext), FilePermissions); err != nil {
			return err
		}
	}

	projectEnumsPath := pather.Join(projectSettingsDir, jsonSchemaName)

	if err := os.WriteFile(projectEnumsPath, []byte(generateJsonSchema()), FilePermissions); err != nil {
		return err
	}

	return nil
}

func processArgs(args *argsData) error {
	flag.StringVar(&args.InputPath, "config", "", "The input file used for the enum being generated.")
	flag.BoolVar(&args.SkipFormat, "skip-format", false, "Skip source formatting.")
	flag.BoolVar(&args.Debug, "debug", false, "Enabled debugging.")
	flag.StringVar(&args.VsCode, "vscode", "", "Path to project to configure the Visual Studio Code JSON Schema file.")
	flag.Parse()

	if args.VsCode != "" {
		return nil
	}

	if args.InputPath == "" {
		return errors.New("Missing config path.  The input file used for the enum being generated.")
	}

	if !path.IsAbs(args.InputPath) {
		if absPath, err := filepath.Abs(args.InputPath); err != nil {
			return err
		} else {
			args.InputPath = absPath
		}
	}

	if !stringer.EndsWith(args.InputPath, ".enum.yaml") {
		return fmt.Errorf("%v must be a .enum.yaml file\n", args.InputPath)
	}

	if _, err := os.Stat(args.InputPath); err != nil {
		return fmt.Errorf("Invalid config path %v: %w", args.InputPath, err)
	}

	return nil
}

func processEnum(args argsData, enum *enumData) error {
	if bs, err := os.ReadFile(args.InputPath); err == nil {
		if err := yaml.Unmarshal(bs, &enum); err != nil {
			return fmt.Errorf("Can't parse config path %v : %w.", args.InputPath, err)
		}
	} else {
		return fmt.Errorf("Can't load config path %v : %w.", args.InputPath, err)
	}

	if args.SkipFormat {
		enum.SkipFormat = args.SkipFormat
	}

	if args.Debug {
		enum.Debug = args.Debug
	}

	enum.InputPath = args.InputPath

	if enum.OutputPath == "" {
		enum.OutputPath = extentioner.Swap(enum.InputPath, ".yaml", ".go")
	}

	if enum.Package == "" {
		enum.Package = enum.OutputPath
		enum.Package = pather.Paths.Dir(enum.Package)
		enum.Package = pather.Paths.Base(enum.Package)
		enum.Package = stringer.ReplaceInList(enum.Package, []string{"-", " "}, "_")
	}

	var typeConverter func(string) string

	if enum.Serialize.Type != "" {
		if c, err := caser.Converter[string](enum.Serialize.Type); err != nil {
			return err
		} else {
			typeConverter = c
		}
	} else {
		typeConverter = caser.PhraseToPascal[string]
	}

	if enum.Type == "" {
		enum.Type = enum.OutputPath
		enum.Type = pather.Paths.Base(enum.Type)
		enum.Type = extentioner.Strip(enum.Type)
		enum.Type = extentioner.Strip(enum.Type)
		enum.Type = stringer.ReplaceInList(enum.Type, []string{"-"}, " ")
		enum.Type = typeConverter(enum.Type)
	}

	if enum.Struct == "" {
		enum.Struct = enum.Type
		enum.Struct = pluralize.NewClient().Plural(enum.Struct)
	}

	var valueConverter func(string) string
	passthrough := func(s string) string {
		return s
	}

	if !stringer.IsEmpty(enum.Serialize.Value) {
		if c, err := caser.Converter[string](enum.Serialize.Value); err != nil {
			return err
		} else {
			valueConverter = c
		}
	} else {
		valueConverter = passthrough
	}

	for i := 0; i < len(enum.Values); i++ {
		value := enum.Values[i]

		if value.Name == "" {
			return fmt.Errorf("Invalid values[%v] name", i)
		}

		if value.Serialized == "" {
			value.Serialized = valueConverter(value.Name)
		}

		value.Name = stringer.RemoveSymbols(value.Name)
		value.Name = stringer.RemoveSpace(value.Name)
		enum.Values[i] = value
	}

	if enum.Header == "" && enum.HeaderFrom == "" {
		enum.HeaderLines = Header
	}

	if enum.Header != "" {
		enum.HeaderLines = stringer.Split(enum.Header, "\n")
	}

	if enum.HeaderFrom != "" {
		if _, err := os.Stat(enum.HeaderFrom); err != nil {
			return fmt.Errorf("Invalid header from path %v: %w", enum.HeaderFrom, err)
		}

		if bs, err := os.ReadFile(args.InputPath); err != nil {
			return fmt.Errorf("Can't read header from path %v: %w", enum.HeaderFrom, err)
		} else {
			header := string(bs)
			enum.HeaderLines = stringer.Split(header, "\n")
		}
	}

	enum.Header = asciibox.Box(
		enum.HeaderLines,
		asciibox.BoxOptions{Alignment: asciibox.Alignment_Left},
	)

	if args.Overwrite {
		enum.Overwrite = true
	}

	return nil
}

func processWrite(enum enumData, bs []byte) error {
	if pather.Paths.Exists(enum.OutputPath) {
		if enum.Overwrite {
			if _, err := pather.Paths.RemoveErr(enum.OutputPath); err != nil {
				return err
			}
		} else {
			return nil
		}
	}

	dir := pather.Paths.Dir(enum.OutputPath)
	err := os.MkdirAll(dir, FilePermissions)

	if err != nil {
		return err
	}

	if _, err := pather.Paths.RemoveErr(enum.OutputPath); err != nil {
		return err
	}

	if err := os.WriteFile(enum.OutputPath, bs, FilePermissions); err != nil {
		return err
	}

	return nil
}

func processTemplate(enum enumData) ([]byte, error) {
	funcs := template.FuncMap{
		"title": func(s string) string {
			return strings.Title(s)
		},
		"lower": func(s string) string {
			return strings.ToLower(s)
		},
		"lowerFirst": func(s string) string {
			return stringer.ToLowerFirst(s)
		},
	}

	filename := path.Base(enum.OutputPath)
	t, err := template.New(filename).Funcs(funcs).Parse(standaloneTmpl)

	if err != nil {
		return []byte{}, nil
	}

	var b bytes.Buffer

	if err := t.Execute(&b, enum); err != nil {
		return []byte{}, err
	}

	if enum.SkipFormat {
		return b.Bytes(), nil
	} else {
		return format.Source(b.Bytes())
	}
}

var standaloneTmpl = `
{{ .Header }}

package {{ .Package }}

import (
	"database/sql/driver"
	"fmt"
	
	"github.com/boundedinfinity/enumer"
)

{{- $typeName := .Type }}
{{- $structName := .Struct }}

type {{ $typeName }} string

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} Stringer implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) String() string {
	return string(t)
}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} JSON marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) MarshalJSON() ([]byte, error) {
	return enumer.MarshalJSON(t)
}

func (t *{{ $typeName }}) UnmarshalJSON(data []byte) error {
	return enumer.UnmarshalJSON(data, t, {{ title $structName }}.Parse)
}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} YAML marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) MarshalYAML() (interface{}, error) {
	return enumer.MarshalYAML(t)
}

func (t *{{ $typeName }}) UnmarshalYAML(unmarshal func(interface{}) error) error {
	return enumer.UnmarshalYAML(unmarshal, t, {{ title $structName }}.Parse)
}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} SQL Database marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) Value() (driver.Value, error) {
	return enumer.Value(t)
}

func (t *{{ $typeName }}) Scan(value interface{}) error {
	return enumer.Scan(value, t, {{ title $structName }}.Parse)
}

// /////////////////////////////////////////////////////////////////
//
//  Enumeration
//
// /////////////////////////////////////////////////////////////////

type {{ lowerFirst $structName }} struct {
{{- range $field := .Values }}
    {{ $field.Name }}  {{ $typeName -}}
{{- end }}
    Values []{{ $typeName }}
    Err error
}

var {{ $structName }} = {{ lowerFirst $structName }}{	
{{- range $field := .Values }}
    {{ $field.Name }}: {{ $typeName -}}("{{- $field.Serialized -}}"),
{{- end }}
	Err: fmt.Errorf("invalid {{ $typeName }}"),
}

func init() {
	{{ title $structName }}.Values = []{{ $typeName -}} {
	{{- range $field := .Values }}
		{{ title $structName }}.{{ $field.Name }},
	{{- end }}
	}
}

func (t {{ lowerFirst $structName }}) newErr(a any, values ...{{ $typeName }}) error {
	return fmt.Errorf(
		"invalid %w value '%v'. Must be one of %v",
		{{ title $structName }}.Err, 
		a, 
		enumer.Join(values, ", "),
	)
}

func (t {{ lowerFirst $structName }}) ParseFrom(v string, values ...{{ $typeName }}) ({{ $typeName }}, error) {
	var found {{ $typeName }}
	var ok bool

	for _, value := range values {
		if enumer.IsEq[string, {{ $typeName }}](v)(value) {
			found = value
			ok = true
			break
		}
	}

	if !ok {
		return found, t.newErr(v, values...)
	}

	return found, nil
}

func (t {{ lowerFirst $structName }}) Parse(v string) ({{ $typeName }}, error) {
	return t.ParseFrom(v, {{ title $structName }}.Values...)
}

func (t {{ lowerFirst $structName }}) IsFrom(v string, values ...{{ $typeName }}) bool {
	for _, value := range values {
		if enumer.IsEq[string, {{ $typeName }}](v)(value) {
			return true
		}
	}
	return false
}

func (t {{ lowerFirst $structName }}) Is(v string) bool {
	return t.IsFrom(v, {{ title $structName }}.Values...)
}
`
