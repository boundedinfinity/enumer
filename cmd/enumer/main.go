package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"github.com/boundedinfinity/asciibox"
	"github.com/boundedinfinity/go-commoner/stringer"
)

const (
	FilePermissions = 0755
)

var (
	Header = []string{
		"===== DO NOT EDIT =====",
		"Manual changes will be overwritten.",
		"Generated by github.com/boundedinfinity/enumer",
	}
)

type argsData struct {
	Path       string
	Header     string
	HeaderFrom string
	SkipFormat bool
	Debug      bool
}

type templateData struct {
	TypeName   string
	StructName string
	Package    string
	Dir        string
	Filename   string
	Path       string
	Variables  []variableField
	BaseType   string
	Header     string
	SkipFormat bool
}

type variableField struct {
	Variable string
	Value    string
}

func main() {
	var args argsData

	data := templateData{
		Variables: []variableField{},
	}

	flag.StringVar(&args.Path, "path", "", "The input file used for the enum being generated.")
	flag.StringVar(&args.Header, "header", "", "The header contents.")
	flag.StringVar(&args.HeaderFrom, "header-from", "", "Path to file containing the header contents.")
	flag.BoolVar(&args.SkipFormat, "skip-format", false, "Skip source formatting.")
	flag.BoolVar(&args.Debug, "debug", false, "Enabled debugging.")
	flag.Parse()

	if err := processArgs(args, &data); err != nil {
		handleErr(err)
	}

	if err := getInfo(args, &data); err != nil {
		handleErr(err)
	}

	if err := processHeader(args, &data); err != nil {
		handleErr(err)
	}

	bs, err := processTemplate(data)

	if err != nil {
		handleErr(err)
	}

	if err := processWrite(data, bs); err != nil {
		handleErr(err)
	}
}

func processArgs(args argsData, data *templateData) error {
	if args.Path == "" {
		return errors.New("input cannot be empty")
	}

	if !stringer.EndsWith(args.Path, ".enum.go") {
		return fmt.Errorf("%v must be a .enum.go file\n", args.Path)
	}

	data.Path = args.Path
	data.Path = strings.ReplaceAll(data.Path, ".enum.go", ".enum.gen.go")

	data.Dir = filepath.Dir(args.Path)
	data.Filename = filepath.Base(args.Path)
	data.SkipFormat = args.SkipFormat

	return nil
}

func getInfo(args argsData, data *templateData) error {
	var err error
	var src []byte

	if src, err = os.ReadFile(args.Path); err != nil {
		return err
	}

	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, data.Path, src, parser.ParseComments)

	if err != nil {
		return err
	}

	type enumContext struct {
		typeName   string
		structName string
		variables  []variableField
	}

	enumCtxMap := map[string]*enumContext{}

	ast.Inspect(parsed, func(astNode ast.Node) bool {
		switch typ := astNode.(type) {
		case *ast.File:
			data.Package = typ.Name.Name
		case *ast.TypeSpec:
			name := typ.Name.Name

			switch structTyp := typ.Type.(type) {
			case *ast.StructType:
				for _, astField := range structTyp.Fields.List {
					fieldType := types.ExprString(astField.Type)

					if enumCtx, ok := enumCtxMap[fieldType]; ok {
						tm, err2 := getStructTagMap(astField)

						if err2 != nil {
							err = err2
							return false
						}

						if enumCtx.structName == "" {
							enumCtx.structName = name
						}

						variableField := variableField{
							Variable: astField.Names[0].Name,
						}

						if v, ok := tm["enum"]; ok {
							variableField.Value = v
						} else {
							variableField.Value = variableField.Variable
						}

						enumCtx.variables = append(enumCtx.variables, variableField)
					}
				}
			case ast.Expr:
				if _, ok := enumCtxMap[name]; !ok {
					enumCtxMap[name] = &enumContext{typeName: name}
				}
			}
		default:
			if args.Debug {
				fmt.Printf("skipping %v\n", typ)
			}
		}

		return true
	})

	if err != nil {
		return err
	}

	for _, ctx := range enumCtxMap {
		if ctx != nil && ctx.structName != "" && len(ctx.variables) > 0 {
			data.TypeName = ctx.typeName
			data.StructName = ctx.structName
			data.Variables = append(data.Variables, ctx.variables...)
		}
	}

	return nil
}

func getStructTagMap(field *ast.Field) (map[string]string, error) {
	m := map[string]string{}

	if field == nil || field.Tag == nil {
		return m, nil
	}

	all, err := strconv.Unquote(field.Tag.Value)

	if err != nil {
		return m, err
	}

	tags := strings.Split(all, " ")

	for _, tag := range tags {
		kv := strings.Split(tag, ":")

		if len(kv) != 2 {
			return m, fmt.Errorf("invalid tag %v", tag)
		}

		v, err := strconv.Unquote(kv[1])

		if err != nil {
			return m, err
		}

		m[kv[0]] = v
	}

	return m, nil
}

func handleErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func processWrite(data templateData, bs []byte) error {
	err := os.MkdirAll(data.Dir, FilePermissions)

	if err != nil {
		return err
	}

	if err := os.WriteFile(data.Path, bs, FilePermissions); err != nil {
		return err
	}

	return nil
}

func processHeader(args argsData, data *templateData) error {
	var headerContent []string

	if args.Header != "" {
		headerContent = []string{args.Header}
	} else if args.HeaderFrom != "" {
		file, err := os.Open(args.HeaderFrom)

		if err != nil {

			return err
		}

		defer file.Close()

		scanner := bufio.NewScanner(file)
		headerContent = append(headerContent, scanner.Text())

		if err := scanner.Err(); err != nil {
			return err
		}
	} else {
		headerContent = Header
	}

	data.Header = asciibox.Box(
		headerContent,
		asciibox.BoxOptions{
			Alignment: asciibox.Alignment_Left,
		},
	)

	return nil
}

func processTemplate(data templateData) ([]byte, error) {
	funcs := template.FuncMap{
		"title": func(s string) string {
			return strings.Title(s)
		},
		"lower": func(s string) string {
			return strings.ToLower(s)
		},
	}

	t, err := template.New(data.Filename).Funcs(funcs).Parse(standaloneTmpl)

	if err != nil {
		return []byte{}, nil
	}

	var b bytes.Buffer

	if err := t.Execute(&b, data); err != nil {
		return []byte{}, err
	}

	if data.SkipFormat {
		return b.Bytes(), nil
	} else {
		return format.Source(b.Bytes())
	}
}

var standaloneTmpl = `
{{ .Header }}

package {{ .Package }}

import (
	"database/sql/driver"
	"fmt"
	
	"github.com/boundedinfinity/enumer"
)

{{- $typeName := .TypeName }}
{{- $structName := .StructName }}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} Stringer implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) String() string {
	return string(t)
}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} JSON marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) MarshalJSON() ([]byte, error) {
	return enumer.MarshalJSON(t)
}

func (t *{{ $typeName }}) UnmarshalJSON(data []byte) error {
	return enumer.UnmarshalJSON(data, t, {{ title $structName }}.Parse)
}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} YAML marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) MarshalYAML() (interface{}, error) {
	return enumer.MarshalYAML(t)
}

func (t *{{ $typeName }}) UnmarshalYAML(unmarshal func(interface{}) error) error {
	return enumer.UnmarshalYAML(unmarshal, t, {{ title $structName }}.Parse)
}

// /////////////////////////////////////////////////////////////////
//  {{ $typeName }} SQL Database marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t {{ $typeName }}) Value() (driver.Value, error) {
	return enumer.Value(t)
}

func (t *{{ $typeName }}) Scan(value interface{}) error {
	return enumer.Scan(value, t, {{ title $structName }}.Parse)
}

// /////////////////////////////////////////////////////////////////
//
//  Enumeration
//
// /////////////////////////////////////////////////////////////////

var {{ title $structName }} = struct {
	{{ $structName }}
	Err error
	Values []{{ $typeName }}
}{
	{{ $structName }}: {{ $structName }}{
	{{- range $field := .Variables }}
		{{ $field.Variable }}: {{ $typeName -}}("{{- $field.Value -}}"),
	{{- end }}
	},
	Err: fmt.Errorf("invalid {{ $typeName }}"),
}

func init() {
	{{ title $structName }}.Values = []{{ $typeName -}} {
	{{- range $field := .Variables }}
		{{ title $structName }}.{{ $field.Variable }},
	{{- end }}
	}
}

func (t {{ $structName }}) newErr(a any, values ...{{ $typeName }}) error {
	return fmt.Errorf(
		"invalid %w value '%v'. Must be one of %v",
		{{ title $structName }}.Err, 
		a, 
		enumer.Join(values, ", "),
	)
}

func (t {{ $structName }}) ParseFrom(v string, values ...{{ $typeName }}) ({{ $typeName }}, error) {
	var found {{ $typeName }}
	var ok bool

	for _, value := range values {
		if enumer.IsEq[string, {{ $typeName }}](v)(value) {
			found = value
			ok = true
			break
		}
	}

	if !ok {
		return found, t.newErr(v, values...)
	}

	return found, nil
}

func (t {{ $structName }}) Parse(v string) ({{ $typeName }}, error) {
	return t.ParseFrom(v, {{ title $structName }}.Values...)
}

func (t {{ $structName }}) IsFrom(v string, values ...{{ $typeName }}) bool {
	for _, value := range values {
		if enumer.IsEq[string, {{ $typeName }}](v)(value) {
			return true
		}
	}
	return false
}

func (t {{ $structName }}) Is(v string) bool {
	return t.IsFrom(v, {{ title $structName }}.Values...)
}
`
