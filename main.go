package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type data struct {
	Name     string
	Package  string
	Output   string
	Filename string
	Items    []string
}

func main() {
	var args data
	var rawItems string

	flag.StringVar(&args.Name, "name", "", "The name of the enumeration.")
	flag.StringVar(&args.Package, "package", "", "The package of the enumeration.")
	flag.StringVar(&args.Output, "output", "", "The output path of the enumeration.")
	flag.StringVar(&args.Filename, "filename", "", "The output path used for the optinoal being generated.")
	flag.StringVar(&rawItems, "items", "", "The comma separated list of items.")
	flag.Parse()

	if args.Name == "" {
		fmt.Printf("name cannot be empty")
		os.Exit(1)
	}

	if rawItems == "" {
		fmt.Printf("items cannot be empty")
		os.Exit(1)
	}

	args.Items = strings.Split(rawItems, ",")

	if args.Package == "" {
		args.Package = "main"
	}

	if args.Output == "" {
		args.Output = filepath.Join(".", fmt.Sprintf("%v.enumeration.go", args.Name))
	}

	funcs := template.FuncMap{
		"title": func(s string) string {
			return strings.Title(s)
		},
	}

	t, err := template.New(args.Filename).Funcs(funcs).Parse(tmplText)

	if err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

	var b bytes.Buffer

	if err := t.Execute(&b, args); err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

	f, err := format.Source(b.Bytes())

	if err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

	if err := ioutil.WriteFile(args.Output, f, 0755); err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

}

var tmplText = `
////////////////////////////////////////////////////////////////////////
// Generated by bounded/enumeration
////////////////////////////////////////////////////////////////////////

package {{ .Package }}

import (
	"fmt"
	"encoding/json"
	"strings"
)

type {{ .Name }}Enum string

const (
{{ range .Items }}
	{{- $.Name }}_{{ title . }} {{ $.Name }}Enum = "{{ . }}"
{{ end }}
)

var (
	{{ .Name }}Enums = []{{ .Name }}Enum{
	{{ range .Items }}
		{{- $.Name }}_{{ title . }},
	{{ end }}
	}
)

func Is{{ .Name }}Enum(v string) bool {
	var f bool

	for _, e := range {{ .Name }}Enums {
		if string(e) == v {
			f = true
			break
		}
	}

	return f
}

func {{ .Name }}EnumParse(v string) ({{ .Name }}Enum, error) {
	var o {{ .Name }}Enum
	var f bool
	n := strings.ToLower(v)

	for _, e := range {{ .Name }}Enums {
		if strings.ToLower(e.String()) == n {
			o = e
			f = true
			break
		}
	}

	if !f {
		return o, Err{{ .Name }}EnumNotFound(v)
	}

	return o, nil
}

func Err{{ .Name }}EnumNotFound(v string) error {
	var ss []string

	for _, e := range {{ .Name }}Enums {
		ss = append(ss, string(e))
	}
	
	return fmt.Errorf(
		"invalid enumeration type '%v', must be one of %v",
		v, strings.Join(ss, ","),
	)
}

func (t {{ .Name }}Enum) String() string {
	return string(t)
}

func (t {{ .Name }}Enum) MarshalJSON() ([]byte, error) {
	return json.Marshal([]byte(t))
}

func (t *{{ .Name }}Enum) UnmarshalJSON(data []byte) error {
	var s string

	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

    e, err := {{ .Name }}EnumParse(s)

    if err != nil {
        return err
    }

	t = &e

	return nil
}
`
