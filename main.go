package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/ozgio/strutil"
)

type data struct {
	Name     string
	Package  string
	Output   string
	Filename string
	Suffix   string
	Prefix   string
	Items    map[string]string
}

func main() {
	args := data{
		Items: make(map[string]string),
	}
	var itemArgs string

	flag.StringVar(&args.Name, "name", "", "The name of the enumeration.")
	flag.StringVar(&args.Package, "package", "", "The package of the enumeration.")
	flag.StringVar(&args.Output, "output", "", "The output path of the enumeration.")
	flag.StringVar(&args.Filename, "filename", "", "The output path used for the optinoal being generated.")
	flag.StringVar(&args.Prefix, "prefix", "", "Prefix is prepended to each item.")
	flag.StringVar(&args.Suffix, "suffix", "", "Suffix is appended to each item.")
	flag.StringVar(&itemArgs, "items", "", "The comma separated list of items.")
	flag.Parse()

	if args.Name == "" {
		fmt.Printf("name cannot be empty")
		os.Exit(1)
	}

	if itemArgs == "" {
		fmt.Printf("items cannot be empty")
		os.Exit(1)
	}

	for _, v := range strings.Split(itemArgs, ",") {
		k := v
		k = strings.ReplaceAll(k, "-", " ")
		k = strings.ReplaceAll(k, "_", " ")
		k = strutil.ToCamelCase(k)
		args.Items[k] = v
	}

	if args.Package == "" {
		args.Package = "main"
	}

	if args.Output == "" {
		args.Output = filepath.Join(".", fmt.Sprintf("%v.enumeration.go", args.Name))
	}

	funcs := template.FuncMap{
		"title": func(s string) string {
			return strings.Title(s)
		},
	}

	t, err := template.New(args.Filename).Funcs(funcs).Parse(tmplText)

	if err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

	var b bytes.Buffer

	if err := t.Execute(&b, args); err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

	f, err := format.Source(b.Bytes())

	if err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

	if err := ioutil.WriteFile(args.Output, f, 0755); err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

}

var tmplText = `
////////////////////////////////////////////////////////////////////////
// Generated by bounded/enumeration
////////////////////////////////////////////////////////////////////////

package {{ .Package }}

import (
	"fmt"
	"encoding/json"
	"strings"
)

type {{ .Prefix }}{{ .Name }}{{ .Suffix }} string

const (
{{ range $k, $v := .Items }}
	{{- $.Name }}_{{ title $k }} {{ $.Prefix }}{{ $.Name }}{{ $.Suffix }} = "{{ $v }}"
{{ end }}
)

var (
	{{ .Prefix }}{{ .Name }}{{ .Suffix }}s = []{{ .Prefix }}{{ .Name }}{{ .Suffix }}{
	{{ range $k, $v := .Items }}
		{{- $.Name }}_{{ title $k }},
	{{ end }}
	}
)

func Is{{ .Prefix }}{{ .Name }}{{ .Suffix }}(v string) bool {
	var f bool

	for _, e := range {{ .Prefix }}{{ .Name }}{{ .Suffix }}s {
		if string(e) == v {
			f = true
			break
		}
	}

	return f
}

func {{ .Prefix }}{{ .Name }}{{ .Suffix }}Parse(v string) ({{ .Prefix }}{{ .Name }}{{ .Suffix }}, error) {
	var o {{ .Prefix }}{{ .Name }}{{ .Suffix }}
	var f bool
	n := strings.ToLower(v)

	for _, e := range {{ .Prefix }}{{ .Name }}{{ .Suffix }}s {
		if strings.ToLower(e.String()) == n {
			o = e
			f = true
			break
		}
	}

	if !f {
		return o, Err{{ .Prefix }}{{ .Name }}{{ .Suffix }}NotFound(v)
	}

	return o, nil
}

func Err{{ .Prefix }}{{ .Name }}{{ .Suffix }}NotFound(v string) error {
	var ss []string

	for _, e := range {{ .Prefix }}{{ .Name }}{{ .Suffix }}s {
		ss = append(ss, string(e))
	}
	
	return fmt.Errorf(
		"invalid enumeration type '%v', must be one of %v",
		v, strings.Join(ss, ","),
	)
}

func (t {{ .Prefix }}{{ .Name }}{{ .Suffix }}) String() string {
	return string(t)
}

func (t {{ .Prefix }}{{ .Name }}{{ .Suffix }}) MarshalJSON() ([]byte, error) {
	return json.Marshal(string(t))
}

func (t *{{ .Prefix }}{{ .Name }}{{ .Suffix }}) UnmarshalJSON(data []byte) error {
	var s string

	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

    e, err := {{ .Prefix }}{{ .Name }}{{ .Suffix }}Parse(s)

    if err != nil {
        return err
    }

	t = &e

	return nil
}
`
