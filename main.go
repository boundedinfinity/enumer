package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/boundedinfinity/asciibox"
)

const (
	FilePermissions = 0755
)

var (
	Header = []string{
		"===== DO NOT EDIT =====",
		"Any change will be overwritten",
		"Generated by github.com/boundedinfinity/enumer",
	}
)

func main() {
	var args argsData

	data := templateData{
		Items: []string{},
	}

	flag.StringVar(&args.Path, "path", "", "The input file used for the enum being generated.")
	flag.StringVar(&args.Plural, "plural", "", "The plural form of the name. Defaults to <name>s.")
	flag.StringVar(&args.Header, "header", "", "The header contents.")
	flag.StringVar(&args.HeaderFrom, "header-from", "", "Path to file containing the header contents.")
	flag.Parse()

	if err := processArgs(args, &data); err != nil {
		handleErr(err)
	}

	if err := getInfo(args, &data); err != nil {
		handleErr(err)
	}

	if err := processHeader(args, &data); err != nil {
		handleErr(err)
	}

	bs, err := processTemplate(data)

	if err != nil {
		handleErr(err)
	}

	if err := processWrite(data, bs); err != nil {
		handleErr(err)
	}
}

func processArgs(args argsData, data *templateData) error {
	if args.Path == "" {
		return errors.New("input cannot be empty")
	}

	if filepath.Ext(args.Path) != ".go" {
		return errors.New("must be a go file")
	}

	data.Path = args.Path
	data.Path = strings.ReplaceAll(data.Path, ".go", ".enum.go")

	data.Dir = filepath.Dir(args.Path)
	data.Filename = filepath.Base(args.Path)

	return nil
}

func getInfo(args argsData, data *templateData) error {
	src, err := ioutil.ReadFile(args.Path)

	if err != nil {
		return err
	}

	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, data.Path, src, parser.ParseComments)

	if err != nil {
		return err
	}

	ast.Inspect(parsed, func(x ast.Node) bool {
		// fmt.Printf("XXXX: %v = \n", x)

		switch t := x.(type) {
		case *ast.File:
			// fmt.Printf("File: %v\n", t.Name)
			data.Package = t.Name.Name
		case *ast.TypeSpec:
			// fmt.Printf("TypeSpec: %v = %v\n", t.Name, t.Type)
			tname := fmt.Sprintf("%v", t.Type)

			switch tname {
			case "string", "byte", "int":
				if data.BaseType == "" {
					data.BaseType = tname
				} else if data.BaseType != tname {
					msg := fmt.Sprintf("must be of same type was %v, now %v", data.BaseType, tname)
					panic(msg)
				}
			default:
				panic("must be one of string,~int,byte")
			}

			data.Name = t.Name.Name
		case *ast.ValueSpec:
			// fmt.Printf("ValueSpec: %v = %v\n", t.Names, t.Type)

			for _, vname := range t.Names {
				if fmt.Sprintf("%v", t.Type) == data.Name {
					data.Items = append(data.Items, vname.Name)
				}
			}
		}

		return true
	})

	return nil
}

func handleErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

type argsData struct {
	Path       string
	Header     string
	HeaderFrom string
	Plural     string
}

type templateData struct {
	Name     string
	Package  string
	Dir      string
	Filename string
	Path     string
	Items    []string
	BaseType string
	Header   string
}

func processWrite(data templateData, bs []byte) error {
	err := os.MkdirAll(data.Dir, FilePermissions)

	if err != nil {
		return err
	}

	if err := ioutil.WriteFile(data.Path, bs, FilePermissions); err != nil {
		return err
	}

	return nil
}

func processHeader(args argsData, data *templateData) error {
	var headerContent []string

	if args.Header != "" {
		headerContent = []string{args.Header}
	} else if args.HeaderFrom != "" {
		file, err := os.Open(args.HeaderFrom)

		if err != nil {

			return err
		}

		defer file.Close()

		scanner := bufio.NewScanner(file)
		headerContent = append(headerContent, scanner.Text())

		if err := scanner.Err(); err != nil {
			return err
		}
	} else {
		headerContent = Header
	}

	data.Header = asciibox.Box(
		headerContent,
		asciibox.BoxOptions{
			Alignment: asciibox.Alignment_Left,
		},
	)

	return nil
}

func processTemplate(data templateData) ([]byte, error) {
	funcs := template.FuncMap{
		"title": func(s string) string {
			return strings.Title(s)
		},
	}

	t, err := template.New(data.Filename).Funcs(funcs).Parse(standaloneTmpl)

	if err != nil {
		return []byte{}, nil
	}

	var b bytes.Buffer

	if err := t.Execute(&b, data); err != nil {
		return []byte{}, err
	}

	return format.Source(b.Bytes())
}

var standaloneTmpl = `
{{ .Header }}

package {{ .Package }}

import (
	"fmt"
	"errors"
	"encoding/json"

	"github.com/boundedinfinity/commons/slices"
)

var (
	All = []{{ .Name }} {
	{{ range $v := .Items }}
		{{- title $v }},
	{{ end }}
	}
)

func (t {{ .Name }}) String() string {
	return string(t)
}

func Parse(v {{ .BaseType }}) ({{ .Name }}, error) {
	f, ok := slices.FindFn(All, func(x {{ .Name }}) bool {
		return {{ .Name }}(v) == x
	})

	if !ok {
		return f, ErrorV(v)
	}

	return f, nil
}

func Is(s {{ .BaseType }}) bool {
	return slices.ContainsFn(All, func(v {{ .Name }}) bool {
		return {{ .BaseType }}(v) == s
	})
}

var ErrInvalid = errors.New("invalid enumeration type")

func ErrorV(v {{ .BaseType }}) error {
	return fmt.Errorf(
		"%w '%v', must be one of %v",
		ErrInvalid, v, slices.Join(All, ","),
	)
}

func (t {{ .Name }}) MarshalJSON() ([]byte, error) {
	return json.Marshal({{ .BaseType }}(t))
}

func (t *{{ .Name }}) UnmarshalJSON(data []byte) error {
	var v {{ .BaseType }}

	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}

    e, err := Parse(v)

    if err != nil {
        return err
    }

	*t = e

	return nil
}

func (t {{ .Name }}) MarshalYAML() (interface{}, error) {
	return {{ .BaseType }}(t), nil
}

func (t *{{ .Name }}) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var v {{ .BaseType }}

	if err := unmarshal(&v); err != nil {
		return err
	}

	e, err := Parse(v)

	if err != nil {
		return err
	}

	*t = e

	return nil
}
`
