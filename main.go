package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/boundedinfinity/asciibox"
)

const (
	FilePermissions = 0755
)

var (
	Header = []string{
		"===== DO NOT EDIT =====",
		"Any change will be overwritten",
		"Generated by github.com/boundedinfinity/enumer",
	}
)

func main() {
	var args argsData

	data := templateData{
		Items: []string{},
	}

	flag.StringVar(&args.Path, "path", "", "The input file used for the enum being generated.")
	flag.StringVar(&args.Plural, "plural", "", "The plural form of the name. Defaults to <name>s.")
	flag.StringVar(&args.Header, "header", "", "The header contents.")
	flag.StringVar(&args.HeaderFrom, "header-from", "", "Path to file containing the header contents.")
	flag.Parse()

	if err := processArgs(args, &data); err != nil {
		handleErr(err)
	}

	if err := getInfo(args, &data); err != nil {
		handleErr(err)
	}

	if err := processHeader(args, &data); err != nil {
		handleErr(err)
	}

	bs, err := processTemplate(data)

	if err != nil {
		handleErr(err)
	}

	if err := processWrite(data, bs); err != nil {
		handleErr(err)
	}
}

func processArgs(args argsData, data *templateData) error {
	if args.Path == "" {
		return errors.New("input cannot be empty")
	}

	if filepath.Ext(args.Path) != ".go" {
		return errors.New("must be a go file")
	}

	data.Path = args.Path
	data.Path = strings.ReplaceAll(data.Path, ".go", ".enum.go")

	data.Dir = filepath.Dir(args.Path)
	data.Filename = filepath.Base(args.Path)

	return nil
}

func getInfo(args argsData, data *templateData) error {
	src, err := ioutil.ReadFile(args.Path)

	if err != nil {
		return err
	}

	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, data.Path, src, parser.ParseComments)

	if err != nil {
		return err
	}

	ast.Inspect(parsed, func(x ast.Node) bool {
		// fmt.Printf("XXXX: %v = \n", x)

		switch t := x.(type) {
		case *ast.File:
			// fmt.Printf("File: %v\n", t.Name)
			data.Package = t.Name.Name
		case *ast.TypeSpec:
			// fmt.Printf("TypeSpec: %v = %v\n", t.Name, t.Type)

			if fmt.Sprintf("%v", t.Type) != "string" {
				panic("must be string")
			}

			data.Name = t.Name.Name
		case *ast.ValueSpec:
			// fmt.Printf("ValueSpec: %v = %v\n", t.Names, t.Type)

			for _, vname := range t.Names {
				if fmt.Sprintf("%v", t.Type) == data.Name {
					data.Items = append(data.Items, vname.Name)
				}
			}
		}

		return true
	})

	return nil
}

func handleErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

type argsData struct {
	Path       string
	Header     string
	HeaderFrom string
	Plural     string
}

type templateData struct {
	Name     string
	Package  string
	Dir      string
	Filename string
	Path     string
	Items    []string
	Header   string
}

func processWrite(data templateData, bs []byte) error {
	err := os.MkdirAll(data.Dir, FilePermissions)

	if err != nil {
		return err
	}

	if err := ioutil.WriteFile(data.Path, bs, FilePermissions); err != nil {
		return err
	}

	return nil
}

func processHeader(args argsData, data *templateData) error {
	var headerContent []string

	if args.Header != "" {
		headerContent = []string{args.Header}
	} else if args.HeaderFrom != "" {
		file, err := os.Open(args.HeaderFrom)

		if err != nil {

			return err
		}

		defer file.Close()

		scanner := bufio.NewScanner(file)
		headerContent = append(headerContent, scanner.Text())

		if err := scanner.Err(); err != nil {
			return err
		}
	} else {
		headerContent = Header
	}

	data.Header = asciibox.Box(
		headerContent,
		asciibox.BoxOptions{
			Alignment: asciibox.Alignment_Left,
		},
	)

	return nil
}

func processTemplate(data templateData) ([]byte, error) {
	funcs := template.FuncMap{
		"title": func(s string) string {
			return strings.Title(s)
		},
	}

	t, err := template.New(data.Filename).Funcs(funcs).Parse(standaloneTmpl)

	if err != nil {
		return []byte{}, nil
	}

	var b bytes.Buffer

	if err := t.Execute(&b, data); err != nil {
		return []byte{}, err
	}

	return format.Source(b.Bytes())
}

var standaloneTmpl = `
{{ .Header }}

package {{ .Package }}

import (
	"fmt"
	"errors"
	"encoding/json"

	"github.com/boundedinfinity/commons/slices"
	"github.com/boundedinfinity/commons/strings"
)

var (
	All = []{{ .Name }} {
	{{ range $v := .Items }}
		{{- title $v }},
	{{ end }}
	}
)

func pred(s string) func({{ .Name }}) bool {
	return func(v {{ .Name }}) bool {
		return string(v) == s
	}
}

func (t {{ .Name }}) String() string {
	return string(t)
}

func Parse(v string) ({{ .Name }}, error) {
	f, ok := slices.FindFn(All, pred(v))

	if !ok {
		return f, ErrorV(v)
	}

	return f, nil
}

func Is(s string) bool {
	return slices.ContainsFn(All, func(v {{ .Name }}) bool {
		return string(v) == s
	})
}

var ErrInvalid = errors.New("invalid enumeration type")

func ErrorV(v string) error {
	return fmt.Errorf(
		"%w '%v', must be one of %v",
		ErrInvalid, v, strings.Join(All, ","),
	)
}

func (t {{ .Name }}) MarshalJSON() ([]byte, error) {
	return json.Marshal(string(t))
}

func (t *{{ .Name }}) UnmarshalJSON(data []byte) error {
	var s string

	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

    e, err := Parse(s)

    if err != nil {
        return err
    }

	*t = e

	return nil
}

func (t {{ .Name }}) MarshalYAML() (interface{}, error) {
	return string(t), nil
}

func (t *{{ .Name }}) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string

	if err := unmarshal(&s); err != nil {
		return err
	}

	e, err := Parse(s)

	if err != nil {
		return err
	}

	*t = e

	return nil
}
`
