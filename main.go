package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type data struct {
	Name     string
	Package  string
	Output   string
	Filename string
	Items    []string
}

func main() {
	var args data
	var rawItems string

	flag.StringVar(&args.Name, "name", "", "The name of the enumeration.")
	flag.StringVar(&args.Package, "package", "", "The package of the enumeration.")
	flag.StringVar(&args.Output, "output", "", "The output path of the enumeration.")
	flag.StringVar(&args.Filename, "filename", "", "The output path used for the optinoal being generated.")
	flag.StringVar(&rawItems, "items", "", "The comma separated list of items.")
	flag.Parse()

	if args.Name == "" {
		fmt.Printf("name cannot be empty")
		os.Exit(1)
	}

	if rawItems == "" {
		fmt.Printf("items cannot be empty")
		os.Exit(1)
	}

	args.Items = strings.Split(rawItems, ",")

	if args.Package == "" {
		args.Package = "main"
	}

	if args.Output == "" {
		args.Output = filepath.Join(".", fmt.Sprintf("%v.enumeration.go", args.Name))
	}

	funcs := template.FuncMap{
		"title": func(s string) string {
			return strings.Title(s)
		},
	}

	t, err := template.New(args.Filename).Funcs(funcs).Parse(tmplText)

	if err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

	var b bytes.Buffer

	if err := t.Execute(&b, args); err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

	f, err := format.Source(b.Bytes())

	if err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

	if err := ioutil.WriteFile(args.Output, f, 0755); err != nil {
		log.Fatal(err)
		os.Exit(1)
	}

}

var tmplText = `
////////////////////////////////////////////////////////////////////////
// Generated by bounded/enumeration
////////////////////////////////////////////////////////////////////////

package {{ .Package }}

import (
	"fmt"
	"encoding/json"
	"strings"
)

type {{ .Name }}Enum string

const (
{{ range .Items }}
	{{- $.Name }}_{{ title . }} {{ $.Name }}Enum = "{{ . }}"
{{ end }}
)

var (
	{{ .Name }}Enums = []{{ .Name }}Enum{
	{{ range .Items }}
		{{- $.Name }}_{{ title . }},
	{{ end }}
	}
)

func {{ .Name }}EnumFromString(v string) ({{ .Name }}Enum, error) {
	var o {{ .Name }}Enum
	var f bool

	for _, e := range {{ .Name }}Enums {
		if string(e) == v {
			o = e
			f = true
			break
		}
	}

	if !f {
		var ss []string

		for _, e := range {{ .Name }}Enums {
			ss = append(ss, string(e))
		}
		
		format := "invalid enumeration type '%v', must be one of %v"
		
		return o, fmt.Errorf(format, v, strings.Join(ss, ","))
	}

	return o, nil
}

func (t {{ .Name }}Enum) String() string {
	return string(t)
}

func (t {{ .Name }}Enum) MarshalJSON() ([]byte, error) {
	return json.Marshal([]byte(t))
}

func (t *{{ .Name }}Enum) UnmarshalJSON(data []byte) error {
	var s string

	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

    e, err := {{ .Name }}EnumFromString(s)

    if err != nil {
        return err
    }

	t = &e

	return nil
}
`
